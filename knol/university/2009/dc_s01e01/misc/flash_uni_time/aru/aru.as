package {	import flash.display.Sprite;	import flash.events.Event;	public class aru extends Sprite {		//private vars		private var swidth=stage.stageWidth;		private var sheight=stage.stageHeight;		private var minSwidthSheight=Math.min(swidth,sheight);		private var maxSwidthSheight=Math.max(swidth,sheight);		public var k:keys;		public var all=new camera  ;		public var colBullets:Array = new Array();		public var colCyclics:Array = new Array();		public var colCycBullets:Array = new Array();		public var healthRect:Sprite=new StatRect(100,10);		public function aru() {			addChild(all);			var keyboard_sprite = new Sprite();			addChild(keyboard_sprite);			k=new keys(keyboard_sprite);			stage.addEventListener(Event.ENTER_FRAME,on_enter_frame);			//Adding in punch bags			//predefined co-ordinates; 660,280 + 750,370			var curEnCyclic:Sprite = new Enemy_Cyclic();			curEnCyclic.x=660;			curEnCyclic.y=280;			all.addChild(curEnCyclic);			colCyclics.push(curEnCyclic);			var curEnCyclic2:Sprite = new Enemy_Cyclic();			curEnCyclic2.x=750;			curEnCyclic2.y=100;			all.addChild(curEnCyclic2);			colCyclics.push(curEnCyclic2);			var healthRectOverlay:Sprite=new StatRect(100,10);			healthRectOverlay.alpha=0.5;			addChild(healthRectOverlay);			addChild(healthRect);			all.playerG.gotoAndStop("static");		}		//Environmental Variables;		public var gravity:Number=3;		//Player Variables;		public var playerHealth:Number=1;		public var playerGrounded:Boolean=false;		public var playerFlying:Boolean=false;		public var ptimeCurFlight:int=0;		public var pSpeed=1;		public var pvelx=0;		public var pvely=0;		public var pvelyJump=-25;		public var pvelxRun=10*pSpeed;		public var pvelxAirFall=5*pSpeed;		public var pvelxFlight=8*pSpeed;		public var pvelyFlight=-10*pSpeed;		public var ppsnyFlightMin=10;		public var pvelxBullet=15*pSpeed;		public var pvelxRunBullet=0.2;		//Temporary Player Variables		public var playerAirCurDOU:int=1;		public var prevSbar:int=0;		public var curBoom:Sprite;		public function on_enter_frame(event:Event) {			//Testing out bullet, punchbag hitTests.			//BULLETS HIT\\\\\\\\\\\\\\\\\\			//Loopint through each cyclic.			for (var c:int=0; c<colCyclics.length; c++) {				var curCyclic:Enemy_Cyclic;				curCyclic=colCyclics[c] as Enemy_Cyclic;				for (var b:int=0; b<colBullets.length; b++) {					var curBullet:Bullet;					curBullet=colBullets[b] as Bullet;					if (curCyclic.hitTestPoint(curBullet.x+all.x,curBullet.y+all.y,true)) {						curCyclic.health-=0.07;						curBoom=new Boom(20,20);						all.addChild(curBoom);						curBoom.x=curBullet.x;						curBoom.y=curBullet.y;						curBullet.dead=true;					}					//Simultaneously check if first playerbullet is dead, and remove if so.					if (curBullet.dead==true) {						all.removeChild(curBullet);						colBullets.splice(b,1);						b--;					}				}				//Firing Enemy_Cyclic Bullets.				if (curCyclic.bulletRequest==true) {					//fire bullet.\\\\\\					//bullet should fly in direction of player.					//Only fire in certain range					var targetX=all.playerG.x;					var targetY=all.playerG.y-all.playerG.height*2/3;					//var targetX=mouseX-all.x;					//var targetY=mouseY-all.y;					var distanceX=targetX-curCyclic.x;					var distanceY=targetY-curCyclic.y;					var distance=Math.sqrt(Math.pow(distanceX,2)+Math.pow(distanceY,2));					var speed=5;					if (distance<400) {						curCyclic.alpha=1;						var newCycBullet:Sprite=new Bullet(0x0099FF,10,curCyclic.x,curCyclic.y,speed*distanceX/distance,speed*distanceY/distance);						all.addChild(newCycBullet);						colCycBullets.push(newCycBullet);						//reset bulletRequest to false.						curCyclic.bulletRequest=false;					} else {						curCyclic.alpha=0.7;					}				}				//If the enemy is dead, remove it.				if (curCyclic.dead==true) {					all.removeChild(curCyclic);					colCyclics.splice(c,1);				}			}			//Looping through each 'player' - only one - so skip to going though each enemy bullet.			for (var e:int=0; e<colCycBullets.length; e++) {				var curCycBullet:Bullet;				curCycBullet=colCycBullets[e] as Bullet;				if (all.playerG.hitTestPoint(curCycBullet.x+all.x,curCycBullet.y+all.y,false)) {					playerHealth-=0.07;					curBoom=new Boom(20,20);					all.addChild(curBoom);					curBoom.x=curCycBullet.x;					curBoom.y=curCycBullet.y;					curCycBullet.dead=true;				}				if (curCycBullet.dead==true) {					all.removeChild(curCycBullet);					colCycBullets.splice(e,1);				}			}			//Camera 'all' position must be added to the hitTestPoint of EVERYTHING.			playerGrounded=all.ground.hitTestPoint(all.playerG.x+all.x,all.playerG.y+all.y,true);			//ANIMATION			if (playerGrounded==true) {				//all.player.gotoAndStop("grounded");				all.playerG.flight.gotoAndStop("static");			} else {				//all.player.gotoAndStop("notGrounded");			}			//MOTION [ Ground / Jump / Flight ]			//JUMPING\\\\\\\\\\\\\\\\\			//IN AIR, NO FLIGHT, GRAVITY APPLIES, Also Possibility of Flight			if ((playerGrounded==false)&&(playerFlying==false)) {				pvely+=gravity;				pvelx=k.lor()*pvelxAirFall;				//No Going INTO ground.				if (pvely>0) {					if (all.ground.hitTestPoint(all.playerG.x+all.x+pvelx,all.playerG.y+all.y+pvely,true)) {						all.playerG.y=all.ground.y;						pvely=0;					}				}				//Count Up Presses: // chaning to off, if up is let go				if (k.dou()!=playerAirCurDOU) {					playerAirCurDOU=0;				}				//INITIATE FLIGHT - if up is pressed after being let go.				if (playerAirCurDOU==0) {					if (k.dou()==1) {						playerFlying=true;						pvely=0;						pvelx=0;					}				}			}			//GROUNDED\\\\\\\\\\\\\\\\\			//If Player is grounded;			if (playerGrounded==true) {				//make sure it isn't in flying mode anymore.				playerFlying=false;				//Get rid of Falling velocity.				pvely=0;				//Allow for left right movement				pvelx=k.lor()*pvelxRun;				//Animating Left + Right Walks				if (k.lor()!=0) {					all.playerG.gotoAndStop("walk");				} else {					all.playerG.gotoAndStop("static");				}				//Jumping Up				if (k.dou()==1) {					playerAirCurDOU=1;					pvely=pvelyJump;				}			}			//FLYING\\\\\\\\\\\\\\\\\			//Now if player is FLYING:			if ((playerGrounded==false)&&(playerFlying==true)) {				all.playerG.gotoAndStop("flight");				pvelx=k.lor()*pvelxFlight;				pvely=k.dou()*pvelyFlight;				if (all.ground.hitTestPoint(all.playerG.x+all.x+pvelx,all.playerG.y+all.y+pvely+ppsnyFlightMin,true)) {					all.playerG.y=all.ground.y;					pvely=0;					playerFlying=false;				}			}			//SHOOTING\\\\\\\\\\\\\\\			if (k.sbar()==1) {				all.playerG.gotoAndStop("shoot");				if (prevSbar==0) {					//k.lrd(), determines facing direction to shoot.					var newBullet:Sprite=new Bullet(0xFF9933,10,all.playerG.x,all.playerG.y-all.playerG.height*2/3,pvelxBullet*k.lrd(),0);					all.addChild(newBullet);					colBullets.push(newBullet);					//disable auto-shoot					prevSbar=1;					//slow down walk					//pvelx*=pvelxRunBullet;				}			}			//resetting auto-shoot counter			if (k.sbar()==0) {				prevSbar=0;			}			//Health			healthRect.scaleX=playerHealth;			//MOVING PLAYER PER FRAME\\\\\\\\\\			all.playerG.x+=pvelx;			all.playerG.y+=pvely;			if (k.lor()!=0) {				all.playerG.scaleX=k.lor();			}			//MOVING CAMERA/EVERYTHING\\\\\\\\\\			all.x=-(all.playerG.x-swidth/2);		}	}}import flash.display.Sprite;import flash.events.Event;class Boom extends Sprite {	public var bang=new Explosion  ;	public function Boom(w:Number=100, h:Number=100) {		addChild(bang);		bang.width=w;		bang.height=h;		addEventListener(Event.ENTER_FRAME,onEnterFrame);	}	public function onEnterFrame(event:Event):void {		if (bang.currentFrame==bang.totalFrames) {			bang.stop();			removeChild(bang);			removeEventListener(Event.ENTER_FRAME,onEnterFrame);		}	}}class Enemy_Cyclic extends Sprite {	public var health:Number=1;	public var theCyclic=new EnemyCyclic  ;	public var timer:int;	public var lag:int;	public var bulletRequest=false;	public var healthRect;	public var dead:Boolean=false;	public function Enemy_Cyclic() {		addChild(theCyclic);		addEventListener(Event.ENTER_FRAME,onEnterFrame);		timer=0;		lag=10;		var healthRectOverlay=new StatRect(10,50);		addChild(healthRectOverlay);		healthRectOverlay.alpha=0.5;		healthRect=new StatRect(10,50);		addChild(healthRect);	}	public function onEnterFrame(event:Event):void {		if (bulletRequest==false) {			timer++;			if (timer>=lag) {				bulletRequest=true;				timer=0;			}		}		if (health<0) {			health=0;			dead=true;		}		healthRect.scaleY=health;		//bulletRequest is set back to false inside main.	}}class StatRect extends Sprite {	public function StatRect(w:Number=100, h:Number=100) {		graphics.beginFill(0xFF0000,1);		graphics.drawRect(0,0,w,h);		graphics.endFill();	}}import flash.filters.*;class Particle3d extends Sprite {	public var vx:Number;	public var vy:Number;	public var vz:Number;	public var ax:Number;	public var ay:Number;	public var az:Number;	public var vxyz:Boolean;	public var axyz:Boolean;	public function Particle3d(_px:Number=0,_py:Number=0,_pz:Number=0,_vx:Number=0,_vy:Number=0,_vz:Number=0,_ax:Number=0,_ay:Number=0,_az:Number=0) {		x=_px;		y=_py;		z=_pz;		vx=_vx;		vy=_vy;		vz=_vz;		ax=_ax;		ay=_ay;		az=_az;		vxyz=false;		axyz=false;		if (vx!=0||vy!=0||vz!=0) {			vxyz=true;		}		if (ax!=0||ay!=0||az!=0) {			axyz=true;			vxyz=true;		}	}	public function getPxyz() {		return [x,y,z];	}	public function setPxyz(_px:Number=0,_py:Number=0,_pz:Number=0):void {		x=_px;		y=_py;		z=_pz;	}	public function getVxyz() {		return [vx,vy,vz];	}	public function setVxyz(_vx:Number=0,_vy:Number=0,_vz:Number=0):void {		vx=_vx;		vy=_vy;		vz=_vz;		if (vx!=0||vy!=0||vz!=0) {			vxyz=true;		} else {			vxyz=false;		}	}	public function setAxyz(_ax:Number=0,_ay:Number=0,_az:Number=0):void {		ax=_ax;		ay=_ay;		az=_az;		if (ax!=0||ay!=0||az!=0) {			axyz=true;			vxyz=true;		} else {			axyz=false;		}	}	public function update():void {		if (vxyz==true) {			//Only Run if needed too.			if (axyz==true) {				vx+=ax;				vy+=ay;				vz+=az;			}			x+=vx;			y+=vy;			z+=vz;		}	}}class Bullet extends Particle3d {	public var timer:int=0;	public var dieingTimer:int=0;	public var timeOfDeath:int=10;	public var dead:Boolean=false;	public function Bullet(fillColor:int, radius:int,_px,_py,_vx,_vy) {		super(_px,_py,0,_vx,_vy,0,0,0,0);		graphics.beginFill(fillColor,1);		graphics.drawCircle(0,0,radius);		graphics.endFill();		addEventListener(Event.ENTER_FRAME,onEnterFrame);	}	public function onEnterFrame(event:Event):void {		timer++;		//Update the bullet.		this.update();		//Set some extreme boundaries to remove the bullet		//to be refined at final stages		//more than often, child will be removed by removeChild in main f().		//refined bullet f() would have modes; launched, travel, explode, killed		if (timer>100) {			dieingTimer++;			this.scaleX=1-dieingTimer/timeOfDeath;			this.scaleY=this.scaleX;			//this.height=height-radius/timeOfDeath;			//this.width=this.height;			if (dieingTimer>=timeOfDeath) {				dead=true;			}		}		if (dead==true) {			//graphics.clear();			//removeEventListener(Event.ENTER_FRAME,onEnterFrame);		}	}	public function setDead(_dead:Boolean):void {		dead=_dead;	}}