package {	import flash.display.Sprite;	import flash.display.Shape;	import flash.display.Graphics;	import flash.events.Event;	public class main extends Sprite {		//private vars		private var swidth=stage.stageWidth;		private var sheight=stage.stageHeight;		private var minSwidthSheight=Math.min(swidth,sheight);		private var maxSwidthSheight=Math.max(swidth,sheight);		//		//ball properties		private var ballRad=5;		private var ballDiam=ballRad*2;		private var ballHealth=100;		//movement		private var xvel=0;		private var yvel=0;		private var xvelmax=15;		private var yvelmax=15;		private var xacc=2;		private var yacc=2;		private var xdec=0.9;		private var ydec=0.9;		private var borderLeftExtreme=ballDiam;		private var borderRightExtreme=swidth-ballDiam;		private var borderUpExtreme=ballDiam;		private var borderDownExtreme=sheight-ballDiam;		private var bordersVertical=false;		//trail		private var numTrails=20;		private var ballTrailAirX=-3;		private var ballTrailAirY=0;		//ball blocks		private var numBlocks=20;		private var ballBlocksRadMin=10;		private var ballBlocksRadMax=50;		private var ballBlocksVelMin=2;		private var ballBlocksVelMax=10;		private var ballBlocksWidthMin2Restart=5;		//bullets		// x x x ¡|¡ v v v v v I|I i i i i 		// x=bullets that have hit something / now dissapeared from screen		// ¡|¡=bulletsExhausted indicator		// v=bullets that are on screen, (can be in absent mode once completed their missions though)		// I|I=bulletsFired		// i=future available bullets		private var bulletsFired=0;		private var bulletsExhausted=0;		private var bulletVel=13;		private var bulletsLagState=false;		private var bulletsLagTcur=0;		private var bulletsLagTmax=1;//7;		private var bulletsForce=0.6;//stacks to increase size deceleration		//public vars		public var k:keys;		//		public var ball:Shape=new Shape  ;		public var ballItem:Shape=new Shape ;		public var ballTrails:Array=new Array  ;		public var ballBlocks:Array=new Array  ;		public var ballBlocksDecSize:Array=new Array  ;		public var bullets:Array=new Array  ;		public var bulletsExistance:Array=new Array  ;		//inital function		public function main() {			stage.addEventListener(Event.ENTER_FRAME,on_enter_frame);			var keyboard_sprite = new Sprite();			addChild(keyboard_sprite);			k=new keys(keyboard_sprite);			//			//ballTrails			for (var i:int=0; i<numTrails; i++) {				var s:Shape=new Shape  ;				ballTrails.push(s);				//iDrawCircle(ballTrails[i].graphics,1,0x000000,0,0x0033FF,1,0,0,10);				iDrawCircle(ballTrails[i].graphics,1,0x000000,0,0xFFCC00,1,0,0,10);				addChild(ballTrails[i]);				var ballTrailIdPercentage=(numTrails-i)/numTrails;				ballTrails[i].alpha=ballTrailIdPercentage*0.9+0.1;				ballTrails[i].height=ballTrailIdPercentage*18+2;				ballTrails[i].width=ballTrailIdPercentage*18+2;			}			//ballBlocks			for (var h:int=0; h<numBlocks; h++) {				var b:Shape=new Shape  ;				ballBlocks.push(b);				iDrawCircle(ballBlocks[h].graphics,1,0x6633CC,1,0x9933FF,0.7,0,0,ballDiam);				addChild(ballBlocks[h]);				ballBlocks[h].x=-100;//this induces loop, so ballBlocks determine their own characteristics				ballBlocksDecSize[h]=0;				/*var randomRadius=(Math.random()*(ballBlocksRadMax-ballBlocksRadMin)+ballBlocksRadMin);				ballBlocks[h].y=Math.random()*(sheight-randomRadius*2)+randomRadius;				ballBlocks[h].width=randomRadius*2;				ballBlocks[h].height=randomRadius*2;*/			}			//ballItem			iDrawCircle(ballItem.graphics,1,0x0000FF,1,0x00CCFF,0.9,0,0,(ballBlocksRadMin-2));			addChild(ballItem);			ballItem.x=0;			ballItem.y=0;			//ball			iDrawCircle(ball.graphics,3,0xFF9900,1,0xFFCC00,0.8,0,0,10);			addChild(ball);			ball.x=swidth/2;			ball.y=sheight/2;		}		//Every Frame Function		public function on_enter_frame(event:Event) {			//Bullets			bulletsFunction();			//Moving Ball Blocks			OEFBallBlocks();			//ball Item			//ballItem.x=ballBlocks[0].x			//ballItem.y=ballBlocks[0].y			var ballItemVelX=(ball.x-ballItem.x)/5			var ballItemVelY=(ball.y-ballItem.y)/5			var ballItemVelMaxX=50;			var ballItemVelMaxY=50;			if (Math.abs(ballItemVelX)>ballItemVelMaxX) {				ballItemVelX=ballItemVelMaxX*(ballItemVelX)/Math.abs(ballItemVelX);			}			if (Math.abs(ballItemVelY)>ballItemVelMaxY) {				ballItemVelY=ballItemVelMaxY*(ballItemVelY)/Math.abs(ballItemVelY);			}						ballItem.x+=ballItemVelX//(ball.x-ballItem.x)/5			ballItem.y+=ballItemVelY//(ball.y-ballItem.y)/5			//ballItem.y+=(ballItem.y-ball.y)/2			//1st stage; confined to ball blocks			//2nd restricted max movement			//3rd follows ball to @ select posn, no restriction on movement.			//Producing Trail			produceTrail();			//main ball			OEFball();		}		private function bulletsFunction() {			//Creating a New Bullet			if (k.spacebar()==true) {				if (bulletsLagTcur==0) {					var l:Shape = new Shape();					bullets.push(l);					iDrawCircle(bullets[bulletsFired].graphics,1,0x000000,0,0x00CC00,1,0,0,5);					addChild(bullets[bulletsFired]);					bullets[bulletsFired].x=ball.x;					bullets[bulletsFired].y=ball.y;					bulletsExistance[bulletsFired]=true;					bulletsFired++;					bulletsLagTcur=1;//start up the lagging process				} else {					bulletsLagTcur++;					if (bulletsLagTcur>=bulletsLagTmax) {						bulletsLagTcur=0;					}				}			}			//Moving Bullets + hits			for (var i:int=bulletsExhausted; i<bulletsFired; i++) {				if (bulletsExistance[i]==true) {					bullets[i].x+=bulletVel;					//Removing Bullets Existance that Pass Border					if (bullets[i].x>swidth) {						bulletsExistance[i]=false;					}					//Bullets Hitting Blocks					for (var p:int=0; p<numBlocks; p++) {						if (ballBlocks[p].hitTestPoint(bullets[i].x,bullets[i].y,true)) {							bulletsExistance[i]=false;							//unexpectedly speeds up blocks; could be part of play														ballBlocksDecSize[p]+=bulletsForce;							ballBlocks[p].x+=ballBlocksDecSize[p]/2;							//ballBlocks[p].x+=5//ballBlocks[p].width/2;							//fun - if ballBlocksDecSize is -ve, then they get bigger and go backwards =D							//trace(ballBlocksDecSize[p])							/*ballBlocks[p].width-=15;							ballBlocks[p].height=ballBlocks[p].width;							if (ballBlocks[p].width<15) {							ballBlocksRestart(ballBlocks[p]);							}*/						}					}					if (bulletsExistance[i]==false) {						bullets[i].x=0;						bullets[i].y=0;					}				}			}			//Removing Bullets with No Existance			while (bulletsExistance[bulletsExhausted]==false) {				removeChild(bullets[bulletsExhausted]);				bulletsExhausted++;				//removeChild - only removes image of bullets				//bullets themselves still exist, invisibly			}		}		//main ball		private function OEFball() {			//accelerating (keyboard)			var tlor=k.lor();			var tdou=k.dou();			//implementing borders;			if ((ball.x)<=(-xvel/(1-xdec)+borderLeftExtreme)) {				if (tlor==-1) {					tlor=0;				}			}			if ((ball.x)>=(-xvel/(1-xdec)+borderRightExtreme)) {				if (tlor==1) {					tlor=0;				}			}			if (bordersVertical==true) {				if ((ball.y)<=(yvel/(1-ydec)+borderUpExtreme)) {					if (tdou==1) {						tdou=0;					}				}				if ((ball.y)>=(yvel/(1-ydec)+borderDownExtreme)) {					if (tdou==-1) {						tdou=0;					}				}			}			//accelerating			var xvelfut=xvel+tlor*xacc;			var yvelfut=yvel+tdou*yacc;			if (Math.abs(xvelfut)<=xvelmax) {				xvel=xvelfut;			}			if (Math.abs(yvelfut)<=yvelmax) {				yvel=yvelfut;			}			//decelerating (standby)			xvel*=(1-xdec)*Math.abs(tlor)+xdec;			yvel*=(1-ydec)*Math.abs(tdou)+ydec;			//Displaying Movement			//implementing borders 2			if (((ball.x+xvel)>borderLeftExtreme)&&(ball.x+xvel<borderRightExtreme)) {				ball.x+=xvel;			}			if (bordersVertical==true) {				if (((ball.y-yvel)<borderDownExtreme)&&(ball.y-yvel>borderUpExtreme)) {					ball.y-=yvel;				}			} else {				ball.y-=yvel;			}			keepOnStage(ball);			//ball hitTest			for (var b:int=0; b<numBlocks; b++) {				if (ballBlocks[b].hitTestPoint(ball.x,ball.y,true)) {					ballHealth--;					trace(ballHealth);				}			}					}		//Those Purple Planets/Asteroids		private function OEFBallBlocks() {			for (var i:int=0; i<numBlocks; i++) {				//Moving ballBlocks				ballBlocks[i].x-=((ballBlocksRadMax-ballBlocks[i].width/2)/ballBlocksRadMax)*(ballBlocksVelMax-ballBlocksVelMin)+ballBlocksVelMin;				//Looping ballBlocks				keepOnStage4ballBlocks(ballBlocks[i], i);				//Shrinking ballBlocks				ballBlocks[i].width-=ballBlocksDecSize[i];				ballBlocks[i].height=ballBlocks[i].width;				if (ballBlocks[i].width<ballBlocksWidthMin2Restart) {					ballBlocksRestart(ballBlocks[i], i);				}			}		}		//Keeping those Purple Planets on Stage		private function keepOnStage4ballBlocks(mc, id) {			var radius=((mc.width)/2);			if ((-mc.x>radius)||(mc.x>(swidth+radius*2))) {				ballBlocksRestart(mc, id);			}		}		//Looping around / Restarting Purple Planets		private function ballBlocksRestart(mc, id) {			ballBlocksDecSize[id]=0;			var randomRadius=(Math.random()*(ballBlocksRadMax-ballBlocksRadMin)+ballBlocksRadMin);			mc.x=swidth+randomRadius;			mc.y=Math.random()*(sheight-randomRadius*2)+randomRadius;			mc.height=randomRadius*2;			mc.width=randomRadius*2;		}		//Producing the Orange Tail		private function produceTrail() {			ballTrails[0].x=ball.x;			ballTrails[0].y=ball.y;			for (var i:int=(numTrails-1); i>0; i--) {				ballTrails[i].x=ballTrails[i-1].x+ballTrailAirX*i/numTrails;				ballTrails[i].y=ballTrails[i-1].y+ballTrailAirY*i/numTrails;			}		}		//////////////////////////////////////////////////////////////////////////////////////////		//Own Functions://////////////////////////////////////////////////////////////////////////		//////////////////////////////////////////////////////////////////////////////////////////		//animation functions		private function keepOnStage(mc) {			if (mc.x>swidth) {				mc.x=0;			}			if (mc.x<0) {				mc.x=swidth;			}			if (mc.y>sheight) {				mc.y=0;			}			if (mc.y<0) {				mc.y=sheight;			}		}		//Drawing Functions		private function iDrawCircle(target:Graphics, lineWeight:int, lineColor:int, lineAlpha:int, fillColor:int, fillAlpha, cx:int, cy:int, cr:int) {			target.lineStyle(lineWeight, lineColor, lineAlpha);			target.beginFill(fillColor,fillAlpha);			target.drawCircle(cx,cy,cr);//these are the co-ordinates INSIDE the shape, best not be moved.		}		//Calculation Functions		private function reflectionAngle(ox,oy,radius,angleInc,hitMc) {			//radius MUST be ≥ than VELOCITY			var angle=0;			var returnAngle;			var angleAlpha;			var angleBeta;			var firstAngle:Boolean=false;			var secondAngle:Boolean=false;			var curPosnHit:Boolean;			var prevPosnHit:Boolean;			for (var i:int=0; i<1; i++) {				if (angle==0) {					if (hitMc.hitTestPoint(orbitPosition(-1,ox,oy,radius,angle),orbitPosition(1,ox,oy,radius,angle),true)) {						curPosnHit=true;					} else {						curPosnHit=false;					}					prevPosnHit=curPosnHit;					trace("angle==0 has passed");				}				if (hitMc.hitTestPoint(orbitPosition(-1,ox,oy,radius,angle),orbitPosition(1,ox,oy,radius,angle),true)) {					curPosnHit=true;				} else {					curPosnHit=false;				}				if (!(curPosnHit==prevPosnHit)) {					if (curPosnHit==true) {						if (firstAngle==false) {							angleAlpha=angle;							firstAngle=true;							//returnAngle=angle;						}					}					if (curPosnHit==false) {						if (firstAngle==true) {							angleBeta=angle;							secondAngle=true;							//returnAngle=angle;						}					}					trace("alpha: "+firstAngle+" beta: "+secondAngle+" angle: "+angle);					prevPosnHit=curPosnHit;				}				angle+=angleInc;				//Returning Values				if (secondAngle==false) {					i--;				} else {					returnAngle=Math.PI+(angleAlpha+angleBeta)/2;					//for more accuracy and minimizing glitches:					//reduce radius until only one hitWall exists.					//increase angleInc					//smooth out 'hidden' hitTestingWall					return returnAngle;				}				//Precautionary Return				if (angle>(Math.PI*2*5)) {					return false;				}			}		}		private function halveIntervalSafePt(safeptx,safepty,hitptx,hitpty,minimalDistance,hitMc,plane) {			//safeptx,safepty MUST be correct, MUST be a safept, perform check beforehand before undertaking this funtion			var midptx;			var midpty;			while (minimalDistance<dist(safeptx,safepty,hitptx,hitpty)) {				midptx=(safeptx+hitptx)/2;				midpty=(safepty+hitpty)/2;				if (hitMc.hitTestPoint(midptx,midpty,true)) {					hitptx=midptx;					hitpty=midpty;				} else {					safeptx=midptx;					safepty=midpty;				}			}			if (plane==-1) {				return safeptx;			}			if (plane==1) {				return safepty;			}		}		private function dist(x1,y1,x2,y2) {			var distance=Math.sqrt(Math.pow(x2-x1,2)+Math.pow(y2-y1,2));			if (x2<x1) {				distance*=-1;			}			if (y2<y1) {				distance*=-1;			}			return distance;		}		private function orbitPosition(xiy,ox,oy,orbitRadius,angle) {			if (xiy==-1) {				var xposition=orbitRadius*Math.cos(angle)+ox;				return xposition;			}			if (xiy==1) {				var yposition=orbitRadius*Math.sin(angle)+oy;				return yposition;			}		}		private function calculateAngle(ox,oy,ix,iy) {			var angle = Math.atan((iy-oy)/(ix-ox));			if (ix<ox) {				angle=Math.PI+angle;			}			return angle;		}		private function calculateAnglePI(ox,oy,ix,iy) {			var angle=calculateAngle(ox,oy,ix,iy);			while (angle<=(-Math.PI)) {				angle+=2*Math.PI;			}			while (angle>(Math.PI)) {				angle-=2*Math.PI;			}			return angle;		}		private function calculateAngle2PI(ox,oy,ix,iy) {			var angle=calculateAngle(ox,oy,ix,iy);			while (angle<=0) {				angle+=2*Math.PI;			}			while (angle>(Math.PI*2)) {				angle-=2*Math.PI;			}			return angle;		}		private function calculateAngle180(ox,oy,ix,iy) {			var angle=calculateAnglePI(ox,oy,ix,iy);			var degree = angle*360/(Math.PI*2);			return degree;		}		private function calculateAngle360(ox,oy,ix,iy) {			var angle=calculateAngle2PI(ox,oy,ix,iy);			var degree = angle*360/(Math.PI*2);			return degree;		}		private function constrainTo180(degree) {			while (degree<=-180) {				degree+=360;			}			while (degree>180) {				degree-=360;			}			return degree;		}	}}