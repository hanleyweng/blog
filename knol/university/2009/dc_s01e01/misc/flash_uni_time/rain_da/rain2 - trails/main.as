package {	import flash.display.Sprite;	import flash.display.Shape;	import flash.display.Graphics;	import flash.events.Event;	public class main extends Sprite {		//private vars		private var swidth=stage.stageWidth;		private var sheight=stage.stageHeight;		private var minSwidthSheight=Math.min(swidth,sheight);		private var maxSwidthSheight=Math.max(swidth,sheight);		private var gravity=0.4;		private var dropvxMax=2;		private var dropuyMax=10;		private var dropuyMin=5;		private var dropvyFriction=0.3;		private var dropvxFriction=0.8;		private var dropterminalvBounce=2;		private var dropRadius=5;				private var numDroplets=50;		private var initialLag:Boolean=true;		private var iTimer=0;		private var iTimerInc=0.2;		private var iLastDroplet:int=0;				private var numTrails=10;		//public vars		public var dropvx:Array=new Array  ;		public var dropvy:Array=new Array  ;		public var drop:Array=new Array  ;		//inital function		public function main() {			stage.addEventListener(Event.ENTER_FRAME,on_enter_frame);			for (var i:int=0; i<numDroplets; i++) {				var xx=Math.random()*dropvxMax*2-dropvxMax;				dropvx.push(xx);				var yy = Math.random()*(dropuyMax-dropuyMin)+dropuyMin;				dropvy.push(yy);				var a:Array=new Array  ;				drop.push(a);				for (var j:int=0; j<numTrails; j++) {					var s:Shape=new Shape  ;					drop[i].push(s);					iDrawCircle(drop[i][j].graphics,0,0x000000,0,0x0098FF,1,0,0,dropRadius);					addChild(drop[i][j]);					drop[i][j].alpha=(numTrails-j)/numTrails;				}				drop[i][0].x=Math.random()*swidth;				drop[i][0].y=-dropRadius;			}		}		//end initial function		public function on_enter_frame(event:Event) {			//initialLag			if (initialLag==true) {				if (iLastDroplet<numDroplets) {					iTimer+=iTimerInc;					iLastDroplet=Math.floor(iTimer);				}			} else {				iLastDroplet=numDroplets;			}			//producing droplets			for (var i:int=0; i<iLastDroplet; i++) {				positionDroplet(i);			}		}		public function positionDroplet(i:int) {			//initial calculations			dropvy[i]+=gravity;			//if reaches bottom			if (drop[i][0].y+dropvy[i]>sheight-dropRadius) {				//if bounce is very little or bounce out of bounds, restart				if ((dropvy[i]<dropterminalvBounce)||(drop[i][0].x<0)||(drop[i][0].x>swidth)) {					drop[i][0].y=- dropRadius;					drop[i][0].x=Math.random()*swidth;					dropvx[i]=Math.random()*dropvxMax*2-dropvxMax;					dropvy[i]=Math.random()*(dropuyMax-dropuyMin)+dropuyMin;				} else {					//bouncing back up					dropvy[i]*=- dropvyFriction;					dropvx[i]*=dropvxFriction;				}			}			//display			for (var j:int=(numTrails-1); j>0; j--) {				drop[i][j].x=drop[i][j-1].x;				drop[i][j].y=drop[i][j-1].y;			}			drop[i][0].x+=dropvx[i];			drop[i][0].y+=dropvy[i];		}		//Drawing Functions		private function iDrawCircle(target:Graphics, lineWeight:int, lineColor:int, lineAlpha:int, fillColor:int, fillAlpha, cx:int, cy:int, cr:int) {			target.lineStyle(lineWeight, lineColor, lineAlpha);			target.beginFill(fillColor,fillAlpha);			target.drawCircle(cx,cy,cr);//these are the co-ordinates INSIDE the shape, best not be moved.		}		//Calculation Functions		private function dist(x1,y1,x2,y2) {			var distance=Math.sqrt(Math.pow(x2-x1,2)+Math.pow(y2-y1,2));			if (x2<x1) {				distance*=-1;			}			if (y2<y1) {				distance*=-1;			}			return distance;		}		private function orbitPosition(xiy,ox,oy,orbitRadius,angle) {			if (xiy==-1) {				var xposition=orbitRadius*Math.cos(angle)+ox;				return xposition;			}			if (xiy==1) {				var yposition=orbitRadius*Math.sin(angle)+oy;				return yposition;			}		}		private function calculateAngle(ox,oy,ix,iy) {			var angle = Math.atan((iy-oy)/(ix-ox));			if (ix<ox) {				angle=Math.PI+angle;			}			return angle;		}	}}