package {	import flash.display.Sprite;	import flash.display.Shape;	import flash.display.Graphics;	import flash.events.Event;	public class main extends Sprite {		//private vars		private var swidth=stage.stageWidth;		private var sheight=stage.stageHeight;		private var minSwidthSheight=Math.min(swidth,sheight);		private var maxSwidthSheight=Math.max(swidth,sheight);		private var gravity=1;		private var dropvxMax=5;		private var dropuyMax=10;		private var dropuyMin=5;		private var dropvyFriction=0.3;		private var dropvxFriction=0.8;		private var dropterminalvBounce=2;		private var dropRadius=4;		private var drop1vx=Math.random()*dropvxMax*2-dropvxMax;		private var drop1vy=Math.random()*(dropuyMax-dropuyMin)+dropuyMin;		//public vars		public var drop1:Shape=new Shape  ;		//inital function		public function main() {			stage.addEventListener(Event.ENTER_FRAME,on_enter_frame);			iDrawCircle(drop1.graphics,0,0x000000,0,0x0098FF,1,0,0,dropRadius);			addChild(drop1);			drop1.x=Math.random()*swidth;			drop1.y=- dropRadius;		}		//end initial function		public function on_enter_frame(event:Event) {			positionDroplet();		}				public function positionDroplet() {			//initial calculations			drop1vy+=gravity;			//if reaches bottom			if (drop1.y+drop1vy>sheight+dropRadius) {				//if bounce is very little or bounce out of bounds, restart				if ((drop1vy<dropterminalvBounce)||(drop1.x<0)||(drop1.x>swidth)) {					drop1vy=0;					drop1.y=0;					drop1.x=Math.random()*swidth;					drop1vx=Math.random()*dropvxMax*2-dropvxMax;					drop1vy=Math.random()*(dropuyMax-dropuyMin)+dropuyMin				} else {					//bouncing back up					drop1vy*=- dropvyFriction;					drop1vx*=dropvxFriction;				}			}			//display			drop1.x+=drop1vx;			drop1.y+=drop1vy;		}				//Drawing Functions		private function iDrawCircle(target:Graphics, lineWeight:int, lineColor:int, lineAlpha:int, fillColor:int, fillAlpha, cx:int, cy:int, cr:int) {			target.lineStyle(lineWeight, lineColor, lineAlpha);			target.beginFill(fillColor,fillAlpha);			target.drawCircle(cx,cy,cr);//these are the co-ordinates INSIDE the shape, best not be moved.		}		//Calculation Functions		private function dist(x1,y1,x2,y2) {			var distance=Math.sqrt(Math.pow(x2-x1,2)+Math.pow(y2-y1,2));			if (x2<x1) {				distance*=-1;			}			if (y2<y1) {				distance*=-1;			}			return distance;		}		private function orbitPosition(xiy,ox,oy,orbitRadius,angle) {			if (xiy==-1) {				var xposition=orbitRadius*Math.cos(angle)+ox;				return xposition;			}			if (xiy==1) {				var yposition=orbitRadius*Math.sin(angle)+oy;				return yposition;			}		}		private function calculateAngle(ox,oy,ix,iy) {			var angle = Math.atan((iy-oy)/(ix-ox));			if (ix<ox) {				angle=Math.PI+angle;			}			return angle;		}	}}