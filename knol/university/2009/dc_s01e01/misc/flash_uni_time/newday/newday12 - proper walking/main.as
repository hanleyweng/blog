package {	import flash.display.Sprite;	import flash.events.Event;	public class main extends Sprite {		private var t_cur=0;//-2*Math.PI;		private var t_int=Math.PI/30;		private var t_max=-2*Math.PI+0.01;		private var tran_amp=100;		private var fps=24;		private var t_turn_cur=4;		private var t_turn_max=4;		private var vel_wlk_dir=0;		private var vel_wlk_cur=0;		private var vel_wlk_rtn=10;		private var vel_wlk_int=2;		private var vel_wlk_max=15;//vel_wlk - intricate relationship - t_int		private var lrb=0;		private var midxstage=stage.stageWidth/2;		private var bound_bg_l=0;		private var bound_bg_r=0;		private var bound_bg_r_in=0;		private var wlk_acc=4;		private var wlk_dec=wlk_acc/1;		private var wlk_vel=0;		private var wlk_vel_max=wlk_acc*8;		private var gpreyhit=0;		private var gcuryhit=0;		private var gptyboxi=0;		private var gymax=20;		private var gyint=2;		private var gycnt=0;		public var k:keys;		public var all=new rootbox  ;		public function main() {			addChild(all);			var keyboard_sprite = new Sprite();			addChild(keyboard_sprite);			k=new keys(keyboard_sprite);			stage.addEventListener(Event.ENTER_FRAME,on_enter_frame);			bound_bg_r=- all.bg.width;			bound_bg_r_in=bound_bg_r+stage.stageWidth;			all.bg.x=bound_bg_l;			all.boxi.x=midxstage;			all.boxi.y=stage.stageHeight/2+36;			all.boxi.stop();			all.testfgi.z=-100;			all.testfgi.alpha=0.75;		}		public function on_enter_frame(event:Event) {			//Action			if (k.lor()*wlk_vel<wlk_vel_max) {				wlk_vel+=k.lor()*wlk_acc;			}			if ( (k.lor()==0)&&(!wlk_vel==0)) {				wlk_vel-=wlk_vel/Math.abs(wlk_vel)*wlk_dec;			}			//display			all.boxi.gotoAndStop(k.lrd()+2);			//glitches - passing >stages< - wlk_vel separate for bg and boxi			//…values [0][400] > variables			if (! wlk_vel==0) {				for (gycnt=0; gycnt<=gymax; gycnt+=gyint) {					if (all.platform.hitTestPoint(all.boxi.x+wlk_vel,all.boxi.y,true)) {						gcuryhit=1;					} else {						gcuryhit=-1;					}					if (gycnt==0) {						gpreyhit=gcuryhit;					}					if (gcuryhit==gpreyhit) {						all.boxi.y-=gcuryhit*gyint;						if (gycnt==gymax) {							all.boxi.y+=gcuryhit*(gymax+gyint);							if (gcuryhit==1) {								//stops at walls - not cliffs as well								wlk_vel=0;							}						}					}					if (gcuryhit==- gpreyhit) {						if (gpreyhit==1) {							all.boxi.y-=gcuryhit*gyint;						}						gycnt=gymax;					}				}			}			if ((all.bg.x-wlk_vel<=0)&&(all.boxi.x==400)&&(all.bg.x-wlk_vel>=-868.9)) {				//mstage				//[all] can't be rescaled by only adjusting it's aspects				all.bg.x-=wlk_vel;//*1.5			} else {				if (Math.abs(all.bg.x)<wlk_vel_max) {					//lstage					if (all.boxi.x+wlk_vel>400) {						all.boxi.x=400;					} else {						if ((all.boxi.x+wlk_vel)>0) {							all.boxi.x+=wlk_vel-all.bg.x;						} else {							all.boxi.x=0;							wlk_vel=0;						}						all.bg.x=0;					}				} else {					//rstage					if (all.boxi.x+wlk_vel<400) {						all.boxi.x=400;					} else {						if ((all.boxi.x+wlk_vel)<800) {							all.boxi.x+=wlk_vel-Math.abs(all.bg.x-(-868.9));							all.bg.x=-868.9;						} else {							all.boxi.x=800;							wlk_vel=0;						}					}				}			}			all.testfgi.x=all.bg.x;			all.platform.x=all.bg.x;			//trace(all.platform.x);			//end public function		}	}}