package {	import flash.display.Sprite;	import flash.events.Event;	public class main extends Sprite {		private var t_cur=0;//-2*Math.PI;		private var t_int=Math.PI/30;		private var t_max=-2*Math.PI+0.01;		private var tran_amp=100;		private var fps=24;		private var t_turn_cur=4;		private var t_turn_max=4;		private var vel_wlk_dir=0;		private var vel_wlk_cur=0;		private var vel_wlk_rtn=10;		private var vel_wlk_int=2;		private var vel_wlk_max=15;//vel_wlk - intricate relationship - t_int		private var lrb=0;		private var midxstage=stage.stageWidth/2;		private var bound_bg_l=0;		private var bound_bg_r=0;		private var bound_bg_r_in=0;		private var wlk_acc=4;		private var wlk_dec=wlk_acc/1;		private var wlk_vel=0;		private var wlk_vel_max=wlk_acc*8;		private var gpreyhit=0;		private var gcuryhit=0;		private var gptyboxi=0;		private var gymax=20;		private var gyint=2;		private var gycnt=0;		private var fall_vel=0;		private var jump_vel=20;		private var gravity=4;		private var boxiair=false;		public var k:keys;		public var all=new rootbox  ;		public function main() {			addChild(all);			var keyboard_sprite = new Sprite();			addChild(keyboard_sprite);			k=new keys(keyboard_sprite);			stage.addEventListener(Event.ENTER_FRAME,on_enter_frame);			bound_bg_r=- all.bg.width;			bound_bg_r_in=bound_bg_r+stage.stageWidth;			all.bg.x=bound_bg_l;			all.boxi.x=midxstage;			all.boxi.y=stage.stageHeight/2+36;			all.boxi.stop();			all.testfgi.z=-100;			all.testfgi.alpha=0.75;		}		public function on_enter_frame(event:Event) {			//Action			if (k.lor()*wlk_vel<wlk_vel_max) {				wlk_vel+=k.lor()*wlk_acc;			}			if ( (k.lor()==0)&&(!wlk_vel==0)) {				wlk_vel-=wlk_vel/Math.abs(wlk_vel)*wlk_dec;			}			//jump			if (k.upi()&&(boxiair==false)) {				fall_vel=- jump_vel-gravity;				boxiair=true;			}			if (boxiair==true) {				//wlk_vel=0; // temporarily nullfies boxiair==false for {grounded}				if (fall_vel<0) {					if (all.platform.hitTestPoint(all.boxi.x+wlk_vel,all.boxi.y+fall_vel,true)) {						if (fall_vel==- jump_vel-gravity) {							if (!all.platform.hitTestPoint(all.boxi.x+wlk_vel,all.boxi.y-5,true)) {								all.boxi.y-=5;							}							if (!all.platform.hitTestPoint(all.boxi.x+wlk_vel,all.boxi.y-10,true)) {								all.boxi.y-=5;							}							if (!all.platform.hitTestPoint(all.boxi.x+wlk_vel,all.boxi.y-15,true)) {								all.boxi.y-=5;							}						}						fall_vel=0;					}				}				fall_vel+=gravity;				all.boxi.y+=fall_vel;				if (all.platform.hitTestPoint(all.boxi.x+wlk_vel,all.boxi.y,true)) {					boxiair=false;					all.boxi.y-=fall_vel/2;					//sometimes gravity } fall_vel drags boxi down lower than gymax -- variables: fall_vel; gravity, jump_vel					for (gycnt=0; gycnt<=gymax; gycnt+=gyint) {						if (all.platform.hitTestPoint(all.boxi.x+wlk_vel,all.boxi.y,true)) {							gcuryhit=1;						} else {							gcuryhit=-1;						}						if (gycnt==0) {							gpreyhit=gcuryhit;						}						if (gcuryhit==gpreyhit) {							all.boxi.y-=gcuryhit*gyint;							if (gycnt==gymax) {								all.boxi.y+=gcuryhit*(gymax+gyint);								if (gcuryhit==1) {									//stops at walls - not cliffs as well									wlk_vel=0;								}							}						}						if (gcuryhit==- gpreyhit) {							if (gpreyhit==1) {								all.boxi.y-=gcuryhit*gyint;							}							gycnt=gymax;						}					}				}			}			//end jump			all.boxi.gotoAndStop(k.lrd()+2);			//glitches - passing >stages< - wlk_vel separate for bg and boxi			//…values [0][400] > variables			//grounded			if ((! wlk_vel==0)&&(boxiair==false)) {				for (gycnt=0; gycnt<=gymax; gycnt+=gyint) {					if (all.platform.hitTestPoint(all.boxi.x+wlk_vel,all.boxi.y,true)) {						gcuryhit=1;					} else {						gcuryhit=-1;					}					if (gycnt==0) {						gpreyhit=gcuryhit;					}					if (gcuryhit==gpreyhit) {						all.boxi.y-=gcuryhit*gyint;						if (gycnt==gymax) {							all.boxi.y+=gcuryhit*(gymax+gyint);							if (gcuryhit==1) {								//stops at walls - not cliffs as well								wlk_vel=0;							}							if (gcuryhit==-1) {								boxiair=true;							}						}					}					if (gcuryhit==- gpreyhit) {						if (gpreyhit==1) {							all.boxi.y-=gcuryhit*gyint;						}						gycnt=gymax;					}				}			}			//end grounded			//camera bounds			if ((all.bg.x-wlk_vel<=0)&&(all.boxi.x==400)&&(all.bg.x-wlk_vel>=-868.9)) {				//mstage				//[all] can't be rescaled by only adjusting it's aspects				all.bg.x-=wlk_vel;//*1.5			} else {				if (Math.abs(all.bg.x)<wlk_vel_max) {					//lstage					if (all.boxi.x+wlk_vel>400) {						all.boxi.x=400;					} else {						if ((all.boxi.x+wlk_vel)>0) {							all.boxi.x+=wlk_vel-all.bg.x;						} else {							all.boxi.x=0;							wlk_vel=0;						}						all.bg.x=0;					}				} else {					//rstage					if (all.boxi.x+wlk_vel<400) {						all.boxi.x=400;					} else {						if ((all.boxi.x+wlk_vel)<800) {							all.boxi.x+=wlk_vel-Math.abs(all.bg.x-(-868.9));							all.bg.x=-868.9;						} else {							all.boxi.x=800;							wlk_vel=0;						}					}				}			}			all.testfgi.x=all.bg.x;			all.platform.x=all.bg.x;			//end camera bounds		}	}}