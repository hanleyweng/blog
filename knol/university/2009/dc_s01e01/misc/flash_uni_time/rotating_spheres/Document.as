//v3_5package {    import flash.display.Sprite;    import flash.display.Shape;    import flash.display.Graphics;    import flash.display.MovieClip;    import flash.events.MouseEvent;    import flash.events.Event;    public class Document extends Sprite {        //private vars        private var swidth=stage.stageWidth;        private var sheight=stage.stageHeight;        private var minSwidthSheight=Math.min(swidth,sheight);        private var maxSwidthSheight=Math.max(swidth,sheight);        //        private var time=0;        //Document Constructor        public function Document() {            /*            var testring:Sprite=new RingPlay(1,100,15,swidth/2,sheight*4/5,0);            addChild(testring);            */            addEventListener(Event.ENTER_FRAME,onEnterFrame);        }        public function onEnterFrame(event:Event):void {            time++;            var numTails=1+10;            if (time<numTails) {                var testring:Sprite=new RingPlay(1-time/numTails,100,6,swidth/2,sheight*4/5,0);                addChild(testring);            }        }    }}import flash.display.Sprite;import flash.events.Event;import flash.geom.Matrix3D;import flash.geom.Matrix;import flash.filters.*;class Particle3d extends Sprite {    public var vx:Number;    public var vy:Number;    public var vz:Number;    public var ax:Number;    public var ay:Number;    public var az:Number;    public var vxyz:Boolean;    public var axyz:Boolean;    public function Particle3d(_px:Number=0,_py:Number=0,_pz:Number=0,_vx:Number=0,_vy:Number=0,_vz:Number=0,_ax:Number=0,_ay:Number=0,_az:Number=0) {        x=_px;        y=_py;        z=_pz;        vx=_vx;        vy=_vy;        vz=_vz;        ax=_ax;        ay=_ay;        az=_az;        vxyz=false;        axyz=false;        if (vx!=0||vy!=0||vz!=0) {            vxyz=true;        }        if (ax!=0||ay!=0||az!=0) {            axyz=true;            vxyz=true;        }        //blendMode="add";        //blendMode="screen";        //blendMode="invert";        //blendMode="darken";        //blendMode="erase";        //http://livedocs.adobe.com/flash/9.0/ActionScriptLangRefV3/flash/display/BlendMode.html    }    public function tracetest():void {        trace("----");    }    public function getPx() {        return x;    }    public function getPy() {        return y;    }    public function getPz() {        return z;    }    public function getPxyz() {        return [x,y,z];    }    public function setPz(_pz:Number=0):void {        z=_pz;    }    public function setPxyz(_px:Number=0,_py:Number=0,_pz:Number=0):void {        x=_px;        y=_py;        z=_pz;    }    public function getVx() {        return vx;    }    public function getVy() {        return vy;    }    public function getVz() {        return vz;    }    public function getVxyz() {        return [vx,vy,vz];    }    public function setVx(_vx:Number=0):void {        vx=_vx;    }    public function setVy(_vy:Number=0):void {        vy=_vy;    }    public function setVz(_vz:Number=0):void {        vz=_vz;    }    public function setVxyz(_vx:Number=0,_vy:Number=0,_vz:Number=0):void {        vx=_vx;        vy=_vy;        vz=_vz;        if (vx!=0||vy!=0||vz!=0) {            vxyz=true;        } else {            vxyz=false;        }    }    public function setAxy(_ax:Number=0,_ay:Number=0,_az:Number=0):void {        ax=_ax;        ay=_ay;        az=_az;        if (ax!=0||ay!=0||az!=0) {            axyz=true;            vxyz=true;        } else {            axyz=false;        }    }    public function update():void {        if (vxyz==true) {            //Only Run if needed too.            if (axyz==true) {                vx+=ax;                vy+=ay;                vz+=az;            }            x+=vx;            y+=vy;            z+=vz;        } else {            //Check if there's new stats.            if (vx!=0||vy!=0||vz!=0) {                vxyz=true;            }            if (ax!=0||ay!=0||az!=0) {                axyz=true;                vxyz=true;            }        }    }}class P_Sphere extends Particle3d {    public function P_Sphere(fillColor:int, fillAlpha, radius:int,_px,_py,_pz,_vx,_vy,_vz,_ax,_ay,_az) {        super(_px,_py,_pz,_vx,_vy,_vz,_ax,_ay,_az);        graphics.beginFill(fillColor,fillAlpha);        graphics.drawCircle(0,0,radius);        graphics.endFill();    }}class InvisiRect extends Sprite {    public function InvisiRect(w:Number=100, h:Number=100) {        graphics.beginFill(0,0);        graphics.drawRect(0,0,w,h);        graphics.endFill();    }}///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////class RingPlay extends Sprite {    public var id:Number;    public var radius:Number;    public var amount:Number;    public var collection:Array = new Array();    public var collectionMode:Array = new Array();    public var shotsList:Array = new Array();    public var timer:int=0;    public var curAngle:Number=0;    public var velAngle:Number=0;    public var velMxAngle:Number = 1/40/2*(2*Math.PI);    public var accTimeAngle:Number=100;    public var accAngle:Number=velMxAngle/accTimeAngle;    public var blurMxPxy:Number=20;    public var pyMxRise:Number=-100;    public var velRise:Number=pyMxRise/accTimeAngle;    public var released:Boolean=false;    public var minGravConstant=0;    public var maxGravConstant=3;    public var curGravConstant=minGravConstant;    public var velGravConstant=0.0008;    public function RingPlay(_id:Number=1,_radius:Number=0,_amount:Number=0,_px:Number=0,_py:Number=0,_pz:Number=0) {        //        id=_id;        radius=_radius;        amount=_amount;        //        setPxyz(_px,_py,_pz);        addEventListener(Event.ENTER_FRAME,onEnterFrame);        //Creating Spheres        var idSqrd=0.5;//Math.pow(id,2);        for (var i:int=0; i<amount; i++) {            var curAngle:Number = i/amount*(2*Math.PI)+curAngle;            var px:Number=Math.sin(curAngle)*radius;            var pz:Number=Math.cos(curAngle)*radius;            var s:Particle3d=new P_Sphere(0xFF9900,idSqrd,5,px,0,pz,0,0,0,0,0,0);            addChild(s);            collection.push(s);            var curMode:int=0;            collectionMode.push(curMode);        }    }    public function setPxyz(_px:Number=0,_py:Number=0,_pz:Number=0) {        x=_px;        y=_py;        z=_pz;    }    public function onEnterFrame(event:Event):void {        timer++;        //Progression from Mn to Mx Velocities        if (timer<=accTimeAngle) {            var pct=timer/accTimeAngle;            var pctSqrd=Math.pow(pct,2);            velAngle+=accAngle;            y+=velRise;            //Filters            var myGlow:GlowFilter = new GlowFilter();//color,alpha,blurX,blurY,strength,quality,inner:Boolean,knockout            myGlow.color=0xFFFF00;            myGlow.alpha=pctSqrd;            myGlow.blurX=blurMxPxy*pct;            myGlow.blurY=blurMxPxy*pct;            filters=[myGlow];            //Distinctive *Pop* at Max            if (timer==accTimeAngle) {                for (var h:int=0; h<amount; h++) {                    var ss:Particle3d;                    ss=collection[h] as Particle3d;                    ss.width*=1.5;                    ss.height*=1.5;                }            }        }        //Release Initiation        if (timer==150) {            released=true;        }        //Spinning the Spheres        curAngle+=velAngle;        for (var i:int=0; i<collection.length; i++) {            var s:Particle3d;            s=collection[i] as Particle3d;            var curMode=collectionMode[i];            if (curMode==0) {                //Mode 0 = continue spinning                //Unnecessary calculation if mode=1.                var curIndiAngle:Number = i/amount*(2*Math.PI)+curAngle;                curIndiAngle = curIndiAngle%(2*Math.PI);                var px:Number=Math.sin(curIndiAngle)*radius;                var pz:Number=Math.cos(curIndiAngle)*radius;                s.setPxyz(px,0,pz);            }            if (released==true) {                if ((curMode==0)&&((curIndiAngle<0.2)||(curIndiAngle>6.0))) {                    //set initial velocities from above variables.                    var prevIndiAngle:Number=curIndiAngle-velAngle;                    var ppx:Number=Math.sin(prevIndiAngle)*radius;                    var ppz:Number=Math.cos(prevIndiAngle)*radius;                    var vx:Number=px-ppx;                    var vz:Number=pz-ppz;                    s.setVxyz(vx,0,vz);                    //initialise mode 1.                    collectionMode[i]=1;                }                //if mode=1;                if (curMode==1) {                    //aligning Pz to 0.                    if (s.getVz()!=0) {                        //bring Vz to 0                        var curVz=s.getVz();                        var deceleration=0.5;                        if (curVz<0) {                            s.setVz(curVz+deceleration);                        } else {                            //if (curVz>=0)                            s.setVz(curVz-deceleration);                        }                        if (Math.abs(curVz)<deceleration) {                            s.setVz(0);                        }                    } else {                        //then bring Pz to 0;                        if (s.getPz()!=0) {                            var curPz=s.getPz();                            var slowDown=3;                            if (curPz<0) {                                s.setPz(curPz+slowDown);                            } else {                                s.setPz(curPz-slowDown);                            }                            if (Math.abs(curPz)<slowDown) {                                s.setPz(0);                            }                        }                    }                    //applying gravitational attraction to s.                    if (curGravConstant<maxGravConstant) {                        curGravConstant+=velGravConstant;                    }                    if (curGravConstant>maxGravConstant) {                        curGravConstant=maxGravConstant;                    }                    //target X/Y need to take central position of ring into consideration.                    var targetX=mouseX;                    var targetY=mouseY;                    var opp=targetY-s.getPy();                    var adj=targetX-s.getPx();                    var hyp=Math.sqrt(Math.pow(opp,2)+Math.pow(adj,2));//distance to target                    s.setVx(s.getVx()+curGravConstant*adj/hyp);                    s.setVy(s.getVy()+curGravConstant*opp/hyp);                    //update s' position.                    s.update();                }            }        }    }}