package {	import flash.display.Sprite;	import flash.events.Event;	public class tiles extends Sprite {		private var mapArr:Array;		private var tilesize=50;		private var defaultmovmxcnt=10		public var w=new whole  ;		public var k:keys;		public function tiles() {			addChild(w);			generatetiles();			generateplayers();			var keyboard_sprite = new Sprite();			3;			addChild(keyboard_sprite);			k=new keys(keyboard_sprite);			stage.addEventListener(Event.ENTER_FRAME,on_enter_frame);		}		public function on_enter_frame(event:Event) {			movingplayers();		}		private function generatetiles() {			var go="go";			var wm="wm";			mapArr = [			[wm,wm,wm,wm,wm,wm,wm,go,wm,wm,wm,go,wm,wm,wm,go],			[wm,wm,wm,wm,wm,wm,wm,wm,wm,wm,wm,wm,wm,wm,wm,wm],			[wm,go,go,go,go,go,go,go,wm,wm,wm,wm,wm,wm,wm,wm],			[wm,go,wm,wm,go,wm,wm,go,go,go,go,go,go,go,go,wm],			[wm,go,go,go,go,wm,wm,wm,wm,wm,wm,wm,wm,go,wm,wm],			[wm,wm,wm,wm,go,go,go,wm,go,go,go,wm,go,go,go,wm],			[wm,go,wm,wm,go,wm,go,go,go,wm,go,go,go,wm,wm,wm],			[wm,wm,wm,wm,wm,wm,wm,wm,wm,wm,wm,wm,wm,wm,wm,wm],			[wm,wm,wm,wm,wm,wm,wm,wm,wm,wm,wm,wm,wm,wm,wm,wm]			];			for (var tr=0; tr<mapArr.length; tr++) {				tn=0;				for (var tn=0; tn<mapArr[tr].length; tn++) {					var ttemp=new tile  ;					w.addChild(ttemp);					ttemp.name="t"+tn+"-"+tr;					w.getChildByName("t"+tn+"-"+tr).width=tilesize;					w.getChildByName("t"+tn+"-"+tr).height=tilesize;					w.getChildByName("t"+tn+"-"+tr).x=tn*tilesize;					w.getChildByName("t"+tn+"-"+tr).y=tr*tilesize;					w.getChildByName("t"+tn+"-"+tr).gotoAndStop(mapArr[tr][tn]);				}			}		}		private function generateplayers() {			var px=new hero  ;			w.addChild(px);			px.name="p"+"1";			w.getChildByName("p"+"1").width=20;			w.getChildByName("p"+"1").height=20;			w.getChildByName("p"+"1").cx=1;			w.getChildByName("p"+"1").cy=2;			w.getChildByName("p"+"1").cfy=w.getChildByName("p"+"1").cy;			w.getChildByName("p"+"1").cfx=w.getChildByName("p"+"1").cx;			w.getChildByName("p"+"1").moving=false;			w.getChildByName("p"+"1").movcucnt=0			w.getChildByName("p"+"1").movmxcnt=defaultmovmxcnt		}		private function movingplayers() {			if (w.getChildByName("p"+"1").moving==false) {				w.getChildByName("p"+"1").x=tilesize*(w.getChildByName("p"+"1").cx)+tilesize/2;				w.getChildByName("p"+"1").y=tilesize*(w.getChildByName("p"+"1").cy)+tilesize/2;				if (k.lrud()==1) {					w.getChildByName("p"+"1").cfy-=k.du();				}				if (k.lrud()==-1) {					w.getChildByName("p"+"1").cfx+=k.lr();				}				if (mapArr[w.getChildByName("p"+"1").cfy][w.getChildByName("p"+"1").cfx]=="go") {					w.getChildByName("p"+"1").moving=true				} else {					// another recheck here if the previous direction was still ok 						// this could be achieved by aquiring the result of the opposite k.lrud() as, the opp must've been chosen to hinder direction						// hence the need to check would most probably be eliminated [ this statement needs to be confirmed - eg scenarios]					// if yes - then cx or cy are altered to the previous direction //or cfx and cfy altered - and then movement=true					// if not - then the following two lines occur - reverting back to previous cx and cy					w.getChildByName("p"+"1").cfy=w.getChildByName("p"+"1").cy;					w.getChildByName("p"+"1").cfx=w.getChildByName("p"+"1").cx;				}			} else {				if (w.getChildByName("p"+"1").movcucnt<w.getChildByName("p"+"1").movmxcnt-1) {					w.getChildByName("p"+"1").x+=tilesize/(w.getChildByName("p"+"1").movmxcnt)*(w.getChildByName("p"+"1").cfx-w.getChildByName("p"+"1").cx)					w.getChildByName("p"+"1").y+=tilesize/(w.getChildByName("p"+"1").movmxcnt)*(w.getChildByName("p"+"1").cfy-w.getChildByName("p"+"1").cy)					w.getChildByName("p"+"1").movcucnt++				} else {					w.getChildByName("p"+"1").movcucnt=0					w.getChildByName("p"+"1").cy=w.getChildByName("p"+"1").cfy;					w.getChildByName("p"+"1").cx=w.getChildByName("p"+"1").cfx;					w.getChildByName("p"+"1").moving=false				}			}		}	}}